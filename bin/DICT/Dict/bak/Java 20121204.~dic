[基础概念]
JRE=JRE（Java Runtime Environment，Java运行环境），运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。
Mylyn=Mylyn（旧称Mylar）是eclipse的一个插件，用于将任务管理和上下文管理无缝集成到Eclipse中。|http://www.blogjava.net/alwayscy/archive/2008/06/15/208022.html /*图文介绍*/
SWT=Standard Widget Toolkit
final=Java和AS3.0关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。
transient=变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。|Java的serialization提供了一种持久化对象实例的机制。|当持久化对象时，可能有一个特殊的对象数据成员，|我们不想用serialization机制来保存它。|为了在一个特定对象的一个域上关闭serialization，|可以在这个域前加上关键字transient。|当一个对象被序列化的时候，transient型变量的值不包括|在序列化的表示中，然而非transient型的变量是被包括进去的。
MINA=Apache MINA(Multipurpose Infrastructure for Network Applications) |是 Apache 组织一个较新的项目它为开发高性能和高可用性的网络应用程序|apache mina  提供了非常便利的框架。|当前发行的 MINA 版本支持基于 Java NIO 技术的 TCP/UDP |应用程序开发、串口通讯程序（只在最新的预览版中提供），|MINA 所支持的功能也在进一步的扩展中。
Hessian=Hessian是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能. |相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，|因为采用的是二进制协议，所以它很适合于发送二进制数据
[学习资料]
推荐书籍=http://wenku.baidu.com/view/1279f6e9856a561252d36f5b.html  /*文库*/|http://blog.csdn.net/ecjtuwh/article/details/4165029  /*推荐了Java学习视频*/
Java编程思想 第4版=http://book.51cto.com/art/200706/49651.htm  /*在线阅读*/
EClipse官方网站=http://www.eclipse.org/|http://www.eclipse.org/birt/phoenix/   /*BIRT*/
Wabacus框架=http://code.google.com/p/wabacus/|http://wabacus.btedu.gov.cn/   /*论坛地址*/|http://wabacus.btedu.gov.cn/WabacusDemo/  /*demo演示*/
[经验技巧]
eclipse格式化代码的快捷键=Ctrl + Shift + F|正确的缩进：CTRL + I
基础类型的数值范围=short 	数值范围：32767 ~ -32768|int 	数值范围：2147483647 ~ -2147483648|long 	数值范围：9223372036854775807 ~ -9223372036854775808|byte 	数值范围：127 ~ -128|float 	数值范围：3.402823e+38 ~ 1.401298e-45|double 	数值范围：1.797693e+308 ~ 4.900000e-324||○测试代码如下：____________________________________|	public static void main(String[] args) throws IOException {|		System.out.printf("short \t数值范围：%d ~ %d\n", Short.MAX_VALUE, Short.MIN_VALUE);|		System.out.printf("int \t数值范围：%d ~ %d\n", Integer.MAX_VALUE, Integer.MIN_VALUE);|		System.out.printf("long \t数值范围：%d ~ %d\n", Long.MAX_VALUE, Long.MIN_VALUE);|		System.out.printf("byte \t数值范围：%d ~ %d\n", Byte.MAX_VALUE, Byte.MIN_VALUE);|		System.out.printf("float \t数值范围：%e ~ %e\n", Float.MAX_VALUE, Float.MIN_VALUE);|		System.out.printf("double \t数值范围：%e ~ %e\n", Double.MAX_VALUE, Double.MIN_VALUE);|	}
static 数据初始化代码实例=//: initialization/StaticInitialization.java|// Specifying initial values in a class definition.|import static net.mindview.util.Print.*;|class Bowl {|	Bowl(int marker) {|		print("Bowl(" + marker + ")");|	}|	void f1(int marker) {|		print("f1(" + marker + ")");|	}|}||class Table {|	static Bowl bowl1 = new Bowl(1);|	Table() {|		print("Table()");|		bowl2.f1(1);|	}|	void f2(int marker) {|		print("f2(" + marker + ")");|	}|	static Bowl bowl2 = new Bowl(2);|}||class Cupboard {|	Bowl bowl3 = new Bowl(3);|	static Bowl bowl4 = new Bowl(4);|	Cupboard() {|		print("Cupboard()");|		bowl4.f1(2);|	}|	void f3(int marker) {|		print("f3(" + marker + ")");|	}|	static Bowl bowl5 = new Bowl(5);|}||public class StaticInitialization {|	public static void main(String[] args) {|		print("Creating new Cupboard() in main");|		new Cupboard();|		print("Creating new Cupboard() in main");|		new Cupboard();|		table.f2(1);|		cupboard.f3(1);|	}|	static Table table = new Table();|	static Cupboard cupboard = new Cupboard();|} |||/* Output:|Bowl(1)|Bowl(2)|Table()|f1(1)|Bowl(4)|Bowl(5)|Bowl(3)|Cupboard()|f1(2)|Creating new Cupboard() in main|Bowl(3)|Cupboard()|f1(2)|Creating new Cupboard() in main|Bowl(3)|Cupboard()|f1(2)|f2(1)|f3(1)|*/
将Date类型转换成字符串的YYYY-MM-DD=java.text.DateFormat   format=new   java.text.SimpleDateFormat( "yyyy-MM-dd "); |java.util.Date   date=new   java.util.Date(); |String   dateString=format.format(date); |System.out.println(dateString);|http://topic.csdn.net/t/20041120/09/3570909.html  /*摘自*/
[BIRT报表]
访问数据列有三种方式=得到的都是数据列id的方法：|row.id|row["id"]|row[1]|http://xulianglly.blog.163.com/blog/static/4361742220111020642884/  /*摘自*/
乱码问题=在标题title,x轴，y轴上相应位置上设置字体为：Simsun(Founder Extended)（Simsun即为宋体）,乱码问题便可得到解决。
分组chart乱码，解决方法=Advanced->Font->Font family->"Arail Unicode MS"|如果没有选择项，可直接写上去
这样的数据才能形成多系列的柱形图=要得到多系列的柱形图主要在于数据，要这样的数据才能形成多系列的柱形图：|name-数目-年份：|A 23 2007|A 22 2006|B 15 2007|B 19 2006|C 30 2007|C 41 2006|这样x轴设置成name,y轴设置成数目，分组设置成年份
怎样在柱形图上显示数字?怎样使数字显示在柱形图的顶端？=在Format Chart选项下，选中Series->Value(Y)Series->把下方的Show Series Labels选项按钮选中即可|要想使数字显示在柱形图的顶端，则还要点击同一页面的Labels按钮，然后在Position下拉框下选择Outside就行了
为什么没有使用 birt report viewer=BIRT Report Viewer 貌似做得很周到，提供如浏览，打印，export to CSV ,过滤参数的传入等一系列的快速操作．|然而细心思考过，这个viewer还是存在不少问题：|如不适用的报表传入参数方式(无输入验证，无日期控件)；代码复杂，可扩展性差......|发现不少功能形同虚设，所以决心抛弃．
为什么不在.rptdesign里写sql=往往实际项目的业务总是复杂的，不希望将复杂的逻辑通过几个简单的参数传入拼凑sql来实现，再说这样调试sql也是一件麻烦的事情，也不利于SQL管理|所以我们提倡 将查询的商业逻辑放回java Manager类，然后designer负责设计数据如何排列。这样子更适合实际项目．
运行报表=我理解为编译报表文件。BIRT在渲染报表之前，要将报表编译为.rptdocument，再根据这个文件将报表渲染为HTML格式或PDF格式。
如何把java代码中参数传递给报表？在报表中又怎样获取这个参数?=通过这种方式给报表传参：|HashMap paramMap = new HashMap();|paramMap.put("birtparam1", 1);|paramMap.put("birtparam2", 5);|task.setParameterValues(paramMap);|设置报表参数与传递的参数同名，这样就关联起来了|数据集参数与报表参数绑定|sql语句中的“?”号对应数据集参数
做交互时在js中获取点击对象的属性值：=Action选择Invoke Script,添写下面的Script代码时，对象的属性要这样查找，不能直接写：|点击fx表达式->在Category里面点击Chart Variables->然后在Sub-Category里面点击Data Points->最后在Double Click to insert里面选择对象的属性，双击它就可以加到上面的表达式中|alert("服务名：" + categoryData + " 值：" + valueData)
Birt的JavaScript脚本简单调试=脚本JavaScriptTomcatJava应用服务器|Birt的JavaScript脚本简单调试||Birt中的js脚本不能用alert直接弹出提示，也没法用断点跟踪(至少我没发现)。用一个简单方法可以打印，在脚本里写上(有脚本的地方就可以加上这条语句，比方说dataset的beforeopen方法中)|importPackage(Packages.java.lang);|System.out.println("test===");|就可以再控制台里打印出来，进行简单的调试了。|需要注意的是，必须要把报表部署在tomcat下才能打印，用Preview预览模式不能打印。|调试样例：|importPackage(Packages.java.lang);|System.out.println("test===*********************************");||var startTime = params["startTime"];|var endTime = params["endTime"];|System.out.println("startTime: " + startTime);|System.out.println("endTime: " + endTime);|if(startTime != null && (!"".equals(startTime)) && endTime != null && (!"".equals(endTime))) {|this.queryText += " where tasklog_2011_8.startTime>='" + startTime + "' and tasklog_2011_8.startTime<='" + endTime + "' or tasklog_2011_8.endTime>='" + startTime + "' and tasklog_2011_8.endTime<='" + endTime + "' group by serviceInstance,status";|} else if(startTime != null && (!"".equals(startTime))) {|this.queryText += " where tasklog_2011_8.startTime>='" + startTime + "' group by serviceInstance,status";|} else if(endTime != null && (!"".equals(endTime))) {|this.queryText += " where tasklog_2011_8.endTime<='" + endTime + "' group by serviceInstance,status";|} else {|this.queryText += " group by serviceInstance,status";|}|System.out.println(this.queryText);|注意Packages|java.*|在应用服务器下运行||最新调试方法：|新建一个报表，并加入一个元素，在其onPrepare中写如下代码||importPackage ( Packages.java.io);|importPackage(Packages.java.lang);|System.setOut(new PrintStream(new java.io.FileOutputStream("c:\\logFile3.txt")));|System.out.print("1");
把数据库中的true和false通过计算列的形式转化成:成功和失败=在数据集中新增计算列，表达式写法：|row["status"].equals("true")?"成功":"失败";|也可以这样写：|var temp = row["status"];|var result = "";|if(temp.equals("true")) {|result = "成功";|}else {|result = "失败";|}|注意最后不要有return result;这条语句，否则会报错
Birt中使用计算列获得星期几的方法=2008-04-24 23:06|var day=row["DiaryDate"].getDay();|var day1="";|switch(day){|case 1:day1="<星期一>"; break;|case 2:day1="<星期二>"; break;|case 3:day1="<星期三>"; break;|case 4:day1="<星期四>"; break;|case 5:day1="<星期五>"; break;|case 6:day1="<星期六>"; break;|default 7: day1="<星期日>";|}|内部机制自动会把day1返回给对应变量，不用专门写return语句
实现交互的时候可以用Invoke Script=里面直接写这样的代码就可以实现给jsp页面上对应的id赋值|document.getElementById("idName").value=Category Data |而且在这里面可以直接调用jsp页面里面定义的js方法，以此来实现交互。
怎样把时间格式定义成这样2011-09-22 16:32:15=我用自定义的形式定义的，后面总要带着上午或下午，怎么能把上午、下午去掉，显示24小时制的时间格式|不影响程序的问题，只是显示的一种形式，跟查询没有关系，因为查询条件是从jsp页面传进去的(24小时时间制)，数据库中也是24小时时间制，报表上的形式只是一种显示形式，无关紧要。|想解决也简单：|自定义格式：yyyy-MM-dd HH:mm:ss|注意HH是大写，大写表示24小时制，小写表示12小时制
表头和表里面的数据中文乱码=预览的时候正常，但在展示的时候显示乱码，这到底是怎么回事？|是因为得到的outstream编码格式不对，只要对它编码就行了，调用ByteArrayOutPutStream的toString("UTF-8")方法，然后把返回的值放到html框架里面就不会乱码了。
[分类]
